 #For BFS:
 #Step 1:Create a graph.
 #Step 2:Make a null adjacency matrix of visited and queue
 #Step 3:Define queue by appending node in visited and queue
 #Step 4:Create a while loop for the queue for popping and printing the nodes which enter the   queue
 #Step 5:Create a for loop to check if neighbor not visited then append i

#For DLS:
#’get_user_input’ is a placeholder for obtaining user input.
#’node is goal’ checks  if the current node is equal to the goal node.
#’depth_limit is 0’ checks if the depth limit has been reached.
#The ‘graph’ is represented as an adjacency list.
# The ‘recursive_dls’ function explores the graph recursively until it finds the goal or reaches the depth limit.

 
graph = {
  'A' : ['B','C'],
  'B' : ['D', 'E'],
  'C' : ['F'],
  'D' : [],
  'E' : [],
  'F' : []
}
 
visited = []  # List for visited nodes.
queue = []	# Initialize a queue
 
def bfs(visited, graph, node):  # Function for BFS
  visited.append(node)
  queue.append(node)
 
  while queue:  # Creating a loop to visit each node
	m = queue.pop(0)
	print(m, end=" ")
 
	for neighbor in graph[m]:
  	if neighbor not in visited:
        visited.append(neighbor)
    	queue.append(neighbor)
 
start_node = 'A'
print(f"Following is the Breadth-First Search starting from node '{start_node}':")
bfs(visited, graph, start_node)  # Function calling
print("\nVisited nodes:", visited)
 
 
 
def dls(node, goal, depth_limit, graph):
	visited = set()
	return recursive_dls(visited, node, goal, depth_limit, graph)
 
def recursive_dls(visited, node, goal, depth_limit, graph):
	if node == goal:
    	return True
	elif depth_limit == 0:
    	return False
	else:
    	visited.add(node)
    	if node in graph:
        	for child in graph[node]:
            	if child not in visited and recursive_dls(visited, child, goal, depth_limit - 1, graph):
                	return True
    	return False
 
graph = {
	'A': ['B', 'C'],
	'B': ['D', 'E'],
	'C': ['F'],
	'D': [],
	'E': [],
	'F': []
}
 
start_node = 'A'
goal_node = 'F'
depth_limit = int(input("Enter the limit: "))
 
result = dls(start_node, goal_node, depth_limit, graph)
print(result)
 
# Output:
# Following is the Breadth-First Search starting from node 'A':
# A B C D E F
# Visited nodes: ['A', 'B', 'C', 'D', 'E', 'F']
 
# Enter the limit: 5
# True

Let's break down the code step by step, explaining each part:

### Breadth-First Search (BFS):

1. Graph Representation:
   - The graph is represented using an adjacency list, where each node is associated with a list of its neighboring nodes.

2. Initialization:
   - `visited`: A list to keep track of visited nodes.
   - `queue`: Initialize an empty queue.

3. BFS Function:
   - `bfs(visited, graph, node)`: This function implements the Breadth-First Search algorithm.
     - It starts by appending the starting node to the `visited` list and the `queue`.
     - Then, it enters a while loop to visit each node in the queue.
     - It pops a node from the queue (`m`) and prints it.
     - For each neighbor of the current node (`m`), if the neighbor has not been visited, it adds it to the `visited` list and the `queue`.

4. Function Call:
   - The BFS function is called with the starting node `'A'`.
   - After the function call, it prints the visited nodes.

### Depth-Limited Search (DLS):

1. DLS Function:
   - `dls(node, goal, depth_limit, graph)`: This function performs Depth-Limited Search.
     - It initializes a set to keep track of visited nodes.
     - It calls the `recursive_dls` function to recursively explore the graph until it finds the goal node or reaches the depth limit.

2. Recursive DLS Function:
   - `recursive_dls(visited, node, goal, depth_limit, graph)`: This function performs the actual recursive depth-limited search.
     - If the current node is equal to the goal node, it returns `True`.
     - If the depth limit is 0, it returns `False`.
     - Otherwise, it marks the current node as visited and recursively explores its children if they haven't been visited and the depth limit hasn't been reached.

3. Function Call:
   - The DLS function is called with the starting node `'A'`, goal node `'F'`, and a depth limit obtained from user input.
   - It prints the result (`True` if the goal node is reachable within the depth limit, otherwise `False`).

### Output:
- The BFS algorithm prints the nodes visited in breadth-first order.
- The Depth-Limited Search algorithm prints whether the goal node is reachable within the specified depth limit.

Let me know if you need further clarification on any part!